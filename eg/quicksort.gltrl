# following the venerable Cormen et al. §7.1

# XXX ASPIRATIONAL: this code does not work (yet, we may hope yet)!

# (:= my_list [3 13 12 0 10 9 4 14 5 2 11 7 6 1 8])

(:=λ swap! |our_list ^[int] an_index ^int another_index ^int| → Void
   (:= temp (_ our_list an_index))
   (_:= our_list an_index (_ our_list another_index))
   (_:= our_list another_index temp))

(:=λ partition! |our_list ^[int] start_index ^int end_index ^int| → ^int
   (:= list_length (length our_list))
   (:= pivot (_ our_list (− list_length 1)))
   (:= lte_boundary (− start_index 1))
   (for |gt_boundary (range start_index (− end_index 1))|
      (when (not_greater? (_ our_list gt_boundary) pivot)
         # TODO: `+:=` as additive augmented assignment?
         # XXX TODO CRITICAL SCOPING CONFUSION: I think this is only
         # creating a local inner binding for `lte_boundary`, not
         # changing the outer one!!
         (:= lte_boundary (+ lte_boundary 1))
         (swap! our_list lte_boundary gt_boundary)))
   (:= pivot_landing (+ lte_boundary 1))
   (swap! our_list pivot_landing (− list_length 1))
   pivot_landing)

(:=λ quicksort! |our_list ^[int] start_index ^int end_index ^int| → Void
   (when (less? start_index end_index)
      (:= pivot (partition! our_list start_index end_index))
      (quicksort! our_list start_index (− pivot 1))
      (quicksort! our_list (+ pivot 1) end_index)))

# (quicksort! my_list 0 14)
# (println! my_list) 

(:= debug_list [2 8 7 1 3 5 6 4])
(:= q (partition! debug_list 0 7))
(println! q)
(print_integer_list debug_list)
