# following the venerable Cormen et al. §7.1

# XXX ASPIRATIONAL: this code does not work (yet, we may hope yet)!

(:= my_list [3 1 0 2 4])

(:=λ swap! |our_list ^[int] an_index ^int another_index ^int| → Void
   (:= temp (_ our_list an_index))
   (_:= our_list an_index (_ our_list another_index))
   (_:= our_list another_index temp))

(:=λ partition! |our_list ^[int] start_index ^int end_index ^int| → ^int
   (:= list_length (length our_list))
   (:= pivot (_ our_list (− list_length 1)))
   (:= lte_boundary (− start_index 1))
   (for |gt_boundary (range start_index end_index)|
      (when (not_greater? (_ our_list gt_boundary) pivot)
         # TODO: `+:=` as additive augmented assignment?
         (:= lte_boundary (+ lte_boundary 1))
         (swap! our_list lte_boundary gt_boundary)))
   (:= pivot_landing (+ lte_boundary 1))
   (swap! our_list pivot_landing (− list_length 1))
   pivot_landing)

(:=λ quicksort! |our_list ^[int] start_index ^int end_index ^int| → Void
   (print_integer_list our_list)  # debug
   (when (less? start_index end_index)
      (:= pivot_point (partition! our_list start_index end_index))
      (quicksort! our_list start_index (− pivot_point 1))
      (quicksort! our_list (+ pivot_point 1) end_index)))

(quicksort! my_list 0 4)
(print_integer_list my_list)
